diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/build_scripts/apple_utils.py ./build_scripts/apple_utils.py
--- /Users/maddyadams/OpenUSD/build_scripts/apple_utils.py	2025-08-26 10:20:00
+++ ./build_scripts/apple_utils.py	2025-11-17 14:56:39
@@ -25,9 +25,12 @@
 TARGET_ARM64 = "arm64"
 TARGET_UNIVERSAL = "universal"
 TARGET_IOS = "iOS"
+TARGET_IOS_SIMULATOR = "iOSSimulator"
 TARGET_VISIONOS = "visionOS"
+TARGET_VISIONOS_SIMULATOR = "visionOSSimulator"
 
-EMBEDDED_PLATFORMS = [TARGET_IOS, TARGET_VISIONOS]
+EMBEDDED_PLATFORMS = [TARGET_IOS, TARGET_IOS_SIMULATOR,
+                      TARGET_VISIONOS, TARGET_VISIONOS_SIMULATOR]
 
 def GetBuildTargets():
     return [TARGET_NATIVE,
@@ -35,7 +38,9 @@
             TARGET_ARM64,
             TARGET_UNIVERSAL,
             TARGET_IOS,
-            TARGET_VISIONOS]
+            TARGET_IOS_SIMULATOR,
+            TARGET_VISIONOS,
+            TARGET_VISIONOS_SIMULATOR]
 
 def GetBuildTargetDefault():
     return TARGET_NATIVE
@@ -120,27 +125,41 @@
     XcodeVersion = XcodeOutput[XcodeFind:].split(' ')[1]
     return (XcodeVersion > '11.0')
 
-def GetSDKRoot(context) -> Optional[str]:
+def GetSDKName(context) -> str:
     sdk = "macosx"
     if context.buildTarget == TARGET_IOS:
-        sdk = "iphoneos"
+        sdk = "iPhoneOS"
+    elif context.buildTarget == TARGET_IOS_SIMULATOR:
+        sdk = "iPhoneSimulator"
     elif context.buildTarget == TARGET_VISIONOS:
-        sdk = "xros"
+        sdk = "xrOS"
+    elif context.buildTarget == TARGET_VISIONOS_SIMULATOR:
+        sdk = "xrSimulator"
 
+    return sdk
+
+def GetSDKRoot(context) -> Optional[str]:
+    sdk = GetSDKName(context).lower()
+
     for arg in (context.cmakeBuildArgs or '').split():
         if "CMAKE_OSX_SYSROOT" in arg:
             override = arg.split('=')[1].strip('"').strip()
             if override:
                 sdk = override
-    return GetCommandOutput(["xcrun", "--sdk", sdk, "--show-sdk-path"])
+    sdkroot = GetCommandOutput(["xcrun", "--sdk", sdk, "--show-sdk-path"])
+    if not sdkroot:
+        raise RuntimeError(f"Could not find an sdk path. Make sure you have the {sdk} sdk installed.")
+    return sdkroot
 
+
 def SetTarget(context, targetName):
     context.targetNative = (targetName == TARGET_NATIVE)
     context.targetX86 = (targetName == TARGET_X86)
     context.targetARM64 = (targetName == GetTargetArmArch())
     context.targetUniversal = (targetName == TARGET_UNIVERSAL)
-    context.targetIOS = (targetName == TARGET_IOS)
-    context.targetVisionOS = (targetName == TARGET_VISIONOS)
+    context.targetIOS = (targetName in (TARGET_IOS, TARGET_IOS_SIMULATOR))
+    context.targetVisionOS = (targetName in (TARGET_VISIONOS, TARGET_VISIONOS_SIMULATOR))
+    context.targetSimulator = (targetName in (TARGET_IOS_SIMULATOR, TARGET_VISIONOS_SIMULATOR))
     if context.targetUniversal and not SupportsMacOSUniversalBinaries():
         context.targetUniversal = False
         raise ValueError(
@@ -153,6 +172,9 @@
             TARGET_UNIVERSAL if context.targetUniversal else
             context.buildTarget)
 
+def GetTargetPlatform(context):
+    return GetTargetName(context).replace("Simulator", "")
+
 devout = open(os.devnull, 'w')
 
 def ExtractFilesRecursive(path, cond):
@@ -238,7 +260,7 @@
 def ConfigureCMakeExtraArgs(context, args:List[str]) -> List[str]:
     system_name = None
     if TargetEmbeddedOS(context):
-        system_name = context.buildTarget
+        system_name = GetTargetPlatform(context)
 
     if system_name:
         args.append(f"-DCMAKE_SYSTEM_NAME={system_name}")
@@ -250,3 +272,38 @@
         args.append(f"-DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=BOTH")
 
     return args
+
+def GetTBBPatches(context):
+    if context.buildTarget not in EMBEDDED_PLATFORMS or context.buildTarget == TARGET_IOS:
+        # TBB already handles these so we don't patch them out
+        return [], []
+
+    sdk_name = GetSDKName(context)
+
+    # Standard Target based names
+    target_config_patches = [("ios", context.buildTarget.lower()),
+                             ("iOS", context.buildTarget),
+                             ("IPHONEOS", sdk_name.upper())]
+
+    clang_config_patches = [("ios",context.buildTarget.lower()),
+                            ("iOS", context.buildTarget),
+                            ("IPHONEOS",sdk_name.upper())]
+
+    if context.buildTarget in (TARGET_VISIONOS, TARGET_VISIONOS_SIMULATOR):
+        target_config_patches.extend([("iPhone", "XR"),
+                                      ("?= 8.0", "?= 1.0")])
+
+        clang_config_patches.append(("iPhone", "XR"),)
+
+    if context.buildTarget == TARGET_VISIONOS:
+        clang_config_patches.append(("-miphoneos-version-min=", "-target arm64-apple-xros"))
+    else:
+        sdk_root = GetSDKRoot(context)
+        version=os.path.basename(sdk_root).split("Simulator")[-1].replace(".sdk","")
+
+        if context.buildTarget == TARGET_VISIONOS_SIMULATOR:
+            clang_config_patches.append(("-miphoneos-version-min=", f"-target arm64-apple-xros{version}-simulator"))
+        elif context.buildTarget == TARGET_IOS_SIMULATOR:
+            clang_config_patches.append(("-miphoneos-version-min=", f"-target arm64-apple-ios{version}-simulator"))
+
+    return target_config_patches, clang_config_patches
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/build_scripts/build_usd.py ./build_scripts/build_usd.py
--- /Users/maddyadams/OpenUSD/build_scripts/build_usd.py	2025-11-17 14:21:56
+++ ./build_scripts/build_usd.py	2025-11-17 14:56:52
@@ -1035,30 +1035,21 @@
                   "ifeq ($(arch),$(filter $(arch),armv7 armv7s {0}))"
                         .format(apple_utils.GetTargetArmArch()))])
 
-        if context.buildTarget == apple_utils.TARGET_VISIONOS:
-            # Create visionOS config from iOS config
+        if MacOSTargetEmbedded(context) and context.buildTarget != apple_utils.TARGET_IOS:
+            target_config_patches, clang_config_patches = apple_utils.GetTBBPatches(context)
+            # Create config from iOS config
             shutil.copy(
                 src="build/ios.macos.inc",
-                dst="build/visionos.macos.inc")
+                dst=f"build/{context.buildTarget.lower()}.macos.inc")
 
-            PatchFile("build/visionos.macos.inc",
-                      [("ios","visionos"),
-                       ("iOS", "visionOS"),
-                       ("iPhone", "XR"),
-                       ("IPHONEOS","XROS"),
-                       ("?= 8.0", "?= 1.0")])
+            PatchFile(f"build/{context.buildTarget.lower()}.macos.inc", target_config_patches)
 
             # iOS clang just reuses the macOS one,
             # so it's easier to copy it directly.
             shutil.copy(src="build/macos.clang.inc",
-                        dst="build/visionos.clang.inc")
+                        dst=f"build/{context.buildTarget.lower()}.clang.inc")
 
-            PatchFile("build/visionos.clang.inc",
-                      [("ios","visionos"),
-                       ("-miphoneos-version-min=", "-target arm64-apple-xros"),
-                       ("iOS", "visionOS"),
-                       ("iPhone", "XR"),
-                       ("IPHONEOS","XROS")])
+            PatchFile(f"build/{context.buildTarget.lower()}.clang.inc",clang_config_patches)
 
         (primaryArch, secondaryArch) = apple_utils.GetTargetArchPair(context)
 
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/base/arch/fileSystem.h ./pxr/base/arch/fileSystem.h
--- /Users/maddyadams/OpenUSD/pxr/base/arch/fileSystem.h	2025-11-17 14:21:56
+++ ./pxr/base/arch/fileSystem.h	2025-11-17 14:57:18
@@ -38,8 +38,6 @@
 #include <stringapiset.h>
 #endif
 
-PXR_NAMESPACE_OPEN_SCOPE
-
 /// \addtogroup group_arch_SystemFunctions
 ///@{
 #if !defined(ARCH_OS_WINDOWS)
@@ -59,6 +57,8 @@
     #define W_OK    2       // Test for write permission.
     #define R_OK    4       // Test for read permission.
 #endif
+
+PXR_NAMESPACE_OPEN_SCOPE
 
 #if defined(ARCH_OS_WINDOWS)
     #define ARCH_GLOB_NOCHECK   1
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/base/tf/CMakeLists.txt ./pxr/base/tf/CMakeLists.txt
--- /Users/maddyadams/OpenUSD/pxr/base/tf/CMakeLists.txt	2025-11-17 14:21:56
+++ ./pxr/base/tf/CMakeLists.txt	2025-11-17 14:57:34
@@ -237,6 +237,7 @@
         pxrTslRobinMap/robin_map.h
         pxrTslRobinMap/robin_set.h
         preprocessorUtilsLite.h
+        retainReleaseHelper.h
         safeTypeCompare.h
         span.h
         staticData.h
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/base/tf/iterator.h ./pxr/base/tf/iterator.h
--- /Users/maddyadams/OpenUSD/pxr/base/tf/iterator.h	2025-08-26 10:20:00
+++ ./pxr/base/tf/iterator.h	2025-11-17 14:57:43
@@ -418,6 +418,7 @@
     using pointer = typename ReverseIterator::pointer;
     using difference_type = typename ReverseIterator::difference_type;
 
+    #if !__swift__
     static_assert(!std::is_reference<reference>::value,
                  "Tf_ProxyReferenceReverseIterator should only be used "
                  "when the underlying iterator's reference type is a "
@@ -427,6 +428,7 @@
                                std::random_access_iterator_tag>::value,
                  "Tf_ProxyReferenceReverseIterator must wrap a random "
                  "access iterator.");
+    #endif // #if !__swift__
 
     Tf_ProxyReferenceReverseIterator() = default;
     explicit Tf_ProxyReferenceReverseIterator(UnderlyingIterator it) :
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/base/tf/notice.h ./pxr/base/tf/notice.h
--- /Users/maddyadams/OpenUSD/pxr/base/tf/notice.h	2025-11-17 14:21:56
+++ ./pxr/base/tf/notice.h	2025-11-17 14:58:09
@@ -263,6 +263,7 @@
 
         friend class Tf_NoticeRegistry;
         friend class TfNotice;
+        friend class SwiftKey;
     };
 
     /// A \c TfNotice::Key container.
@@ -272,6 +273,16 @@
     /// keys into a \c TfNotice::Keys then call \c Revoke() on it.
     typedef std::vector<Key> Keys;
 
+    /// A key representing a listener registered from either Swift or C++
+    class SwiftKey;
+
+    /// A pxr::TfNotice::SwiftKey container.
+    ///
+    /// Many listeners listen for several notices and must revoke interest for
+    /// those several notices at once. These listeners can put all of the
+    /// keys into a `pxr::TfNotice::SwiftKeys` then call ``Revoke()`` on it.
+    typedef std::vector<SwiftKey> SwiftKeys;
+
     /// Register a probe that will be invoked when notices are sent and
     /// delivered.  
     /// \see TfNotice::Probe
@@ -382,7 +393,25 @@
     ///
     /// This revokes interest by the listener for the particular notice type
     /// and call-back method for which this key was created.
+    /// \c Revoke will return a bool value indicating whether or not the key
+    /// was successfully revoked. Subsequent calls to \c Revoke with the same
+    /// key will return false.
+    TF_API
+    static bool Revoke(TfNotice::SwiftKey key);
+
+    /// Revoke interest by listeners.
     ///
+    /// This revokes interest by the listeners for the particular
+    /// notice types and call-back methods for which the keys were
+    /// created. It then clears the keys container.
+    TF_API
+    static void Revoke(TfNotice::SwiftKeys* keys);
+
+    /// Revoke interest by a listener.
+    ///
+    /// This revokes interest by the listener for the particular notice type
+    /// and call-back method for which this key was created.
+    ///
     /// \c Revoke will return a bool value indicating whether or not the key
     /// was successfully revoked.  Subsequent calls to \c Revoke with the same
     /// key will return false.  This will not return while any threads are
@@ -398,7 +427,28 @@
     /// while any threads are invoking any handlers.
     TF_API
     static void RevokeAndWait(TfNotice::Keys* keys);
+    
+    /// Revoke interest by a listener.
+    ///
+    /// This revokes interest by the listener for the particular notice type
+    /// and call-back method for which this key was created.
+    ///
+    /// \c Revoke will return a bool value indicating whether or not the key
+    /// was successfully revoked.  Subsequent calls to \c Revoke with the same
+    /// key will return false.  This will not return while any threads are
+    /// invoking the handler.
+    TF_API
+    static bool RevokeAndWait(TfNotice::SwiftKey key);
 
+    /// Revoke interest by listeners.
+    ///
+    /// This revokes interest by the listeners for the particular
+    /// notice types and call-back methods for which the keys were
+    /// created.  It then clears the keys container.  This will not return
+    /// while any threads are invoking any handlers.
+    TF_API
+    static void RevokeAndWait(TfNotice::SwiftKeys* keys);
+
     /// Deliver the notice to interested listeners, returning the number
     /// of interested listeners.  
     ///
@@ -611,8 +661,8 @@
             typedef typename Derived::NoticeType NoticeType;
             TfType ret = TfType::Find<NoticeType>();
             if (ret.IsUnknown())
-                TF_FATAL_ERROR("notice type " + ArchGetDemangled<NoticeType>() +
-                               " undefined in the TfType system");
+                TF_FATAL_ERROR(("notice type " + ArchGetDemangled<NoticeType>() +
+                                " undefined in the TfType system").c_str());
             return ret;
         }
 
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/base/tf/refBase.h ./pxr/base/tf/refBase.h
--- /Users/maddyadams/OpenUSD/pxr/base/tf/refBase.h	2025-08-26 10:20:00
+++ ./pxr/base/tf/refBase.h	2025-11-17 14:58:25
@@ -125,6 +125,8 @@
 
     template <typename T> friend TfRefPtr<T>
     TfCreateRefPtrFromProtectedWeakPtr(TfWeakPtr<T> const &);
+
+    friend class Tf_RetainReleaseHelper;
 };
 
 /// \class TfSimpleRefBase
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/base/tf/refPtr.h ./pxr/base/tf/refPtr.h
--- /Users/maddyadams/OpenUSD/pxr/base/tf/refPtr.h	2025-08-26 10:20:00
+++ ./pxr/base/tf/refPtr.h	2025-11-17 14:58:37
@@ -423,6 +423,7 @@
 #include <typeinfo>
 #include <type_traits>
 #include <cstddef>
+#include <swift/bridging>
 
 PXR_NAMESPACE_OPEN_SCOPE
 
@@ -934,7 +935,7 @@
     }
 
     /// Dereferences the stored pointer.
-    T& operator *() const {
+    T& operator *() const SWIFT_NAME(__operatorStar()) {
         return *operator->();
     }
 
@@ -1090,6 +1091,10 @@
         _Counter::AddRef(_refBase);
     }
 
+    static void _AddRefStatic(TfRefBase* _refBase) {
+        _Counter::AddRef(_refBase);
+    }
+
     void _RemoveRef(const TfRefBase* ptr) const {
         if (_Counter::RemoveRef(ptr)) {
             Tf_RefPtrTracker_LastRef(this, ptr, _NullT);
@@ -1097,6 +1102,15 @@
         }
     }
 
+    static void _RemoveRefStatic(const TfRefBase* ptr) {
+        if (_Counter::RemoveRef(ptr)) {
+            Tf_RefPtrTracker_LastRef(nullptr,
+                                     reinterpret_cast<T*>(const_cast<TfRefBase*>(ptr)),
+                                     _NullT);
+            delete ptr;
+        }
+    }
+
 #if ! defined(doxygen)
     // doxygen is very confused by this. It declares all TfRefPtrs
     // to be friends.
@@ -1108,6 +1122,7 @@
     friend TfRefPtr<U> TfCreateRefPtrFromProtectedWeakPtr(TfWeakPtr<U> const &);
 #endif
     friend class TfWeakBase;
+    friend class Tf_RetainReleaseHelper;
 };
 
 #if !defined(doxygen)
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/base/tf/retainReleaseHelper.h ./pxr/base/tf/retainReleaseHelper.h
--- /Users/maddyadams/OpenUSD/pxr/base/tf/retainReleaseHelper.h	1969-12-31 16:00:00
+++ ./pxr/base/tf/retainReleaseHelper.h	2025-11-17 14:58:44
@@ -0,0 +1,47 @@
+#ifndef retainReleaseHelper_hpp
+#define retainReleaseHelper_hpp
+
+#include "pxr/pxr.h"
+#include "pxr/base/tf/refBase.h"
+#include "pxr/base/tf/refPtr.h"
+
+PXR_NAMESPACE_OPEN_SCOPE
+
+// This class exposes functions to manually manipulate the reference count of a TfRefBase.
+// Never call these functions directly; they are provided for the purposes of importing TfRefBase
+// with reference counting semantics into a language with automatic reference counting mechanisms.
+
+// TfRefPtr<TfRefBase> isn't supported, so we can't use the static member functions.
+// Instead, just use the no-unique-change-counter body
+class Tf_RetainReleaseHelper {
+public:
+    // Increments the reference count of the argument by 1.
+    template <class T>
+    inline static void retain(T* obj) {
+        if constexpr (std::is_same_v<pxr::TfRefBase, T>) {
+            pxr::Tf_RefPtr_Counter::AddRef(obj);
+        } else {
+            TfRefPtr<T>::_AddRefStatic(obj);
+        }
+    }
+
+    // Decrements the reference count of the argument by 1, deleting the argument
+    // if the reference count reaches 0.
+    template <class T>
+    inline static void release(T* obj) {
+        if constexpr (std::is_same_v<pxr::TfRefBase, T>) {
+            if (pxr::Tf_RefPtr_Counter::RemoveRef(obj)) {
+                pxr::Tf_RefPtrTracker_LastRef(nullptr,
+                                              reinterpret_cast<T*>(const_cast<TfRefBase*>(obj)),
+                                              nullptr);
+                delete obj;
+            }
+        } else{
+            TfRefPtr<T>::_RemoveRefStatic(obj);
+        }
+    }
+};
+
+PXR_NAMESPACE_CLOSE_SCOPE
+
+#endif /* retainReleaseHelper_h */
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/base/tf/weakPtrFacade.h ./pxr/base/tf/weakPtrFacade.h
--- /Users/maddyadams/OpenUSD/pxr/base/tf/weakPtrFacade.h	2025-08-26 10:20:00
+++ ./pxr/base/tf/weakPtrFacade.h	2025-11-17 14:58:53
@@ -17,6 +17,7 @@
 #include "pxr/base/arch/demangle.h"
 
 #include <type_traits>
+#include <swift/bridging>
 
 PXR_NAMESPACE_OPEN_SCOPE
 
@@ -185,7 +186,7 @@
             TF_CALL_CONTEXT, typeid(Derived).name());
     }
 
-    DataType &operator * () const {
+    DataType &operator * () const SWIFT_NAME(__operatorStar()) {
         return * operator->();
     }
 
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/base/vt/dictionary.h ./pxr/base/vt/dictionary.h
--- /Users/maddyadams/OpenUSD/pxr/base/vt/dictionary.h	2025-11-17 14:21:56
+++ ./pxr/base/vt/dictionary.h	2025-11-17 14:59:10
@@ -439,8 +439,8 @@
 {
     VtDictionary::const_iterator i = dictionary.find(key);
     if (ARCH_UNLIKELY(i == dictionary.end())) {
-        TF_FATAL_ERROR("Attempted to get value for key '" + key +
-                       "', which is not in the dictionary.");
+        TF_FATAL_ERROR(("Attempted to get value for key '" + key +
+                        "', which is not in the dictionary.").c_str());
     }
 
     return i->second.Get<T>();
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/exec/exec/CMakeLists.txt ./pxr/exec/exec/CMakeLists.txt
--- /Users/maddyadams/OpenUSD/pxr/exec/exec/CMakeLists.txt	2025-11-17 14:21:56
+++ ./pxr/exec/exec/CMakeLists.txt	2025-11-17 14:59:28
@@ -35,6 +35,7 @@
         systemChangeProcessor
         systemDiagnostics
         typeRegistry
+        valueExtractor
         valueKey
 
     PRIVATE_HEADERS
@@ -74,7 +75,6 @@
         uncompilationTable
         uncompilationTarget
         uncompiler
-        valueExtractor
 
     RESOURCE_FILES
         plugInfo.json
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/exec/vdf/parallelExecutorEngineBase.h ./pxr/exec/vdf/parallelExecutorEngineBase.h
--- /Users/maddyadams/OpenUSD/pxr/exec/vdf/parallelExecutorEngineBase.h	2025-11-17 14:21:56
+++ ./pxr/exec/vdf/parallelExecutorEngineBase.h	2025-11-17 14:59:55
@@ -1885,9 +1885,9 @@
         if (!privateBuffer->GetExecutorCache()) {
             // No output value: Spit out a warning.
             TF_WARN(
-                "No value set for output " + output.GetDebugName() +
-                " of type " + output.GetSpec().GetType().GetTypeName() +
-                " named " + output.GetName().GetString());
+                ("No value set for output " + output.GetDebugName() +
+                 " of type " + output.GetSpec().GetType().GetTypeName() +
+                 " named " + output.GetName().GetString()).c_str());
 
             // Fill the output with a default value.
             VdfExecutionTypeRegistry::FillVector(
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/exec/vdf/poolChainIndex.h ./pxr/exec/vdf/poolChainIndex.h
--- /Users/maddyadams/OpenUSD/pxr/exec/vdf/poolChainIndex.h	2025-08-26 10:20:00
+++ ./pxr/exec/vdf/poolChainIndex.h	2025-11-17 15:00:07
@@ -52,6 +52,9 @@
     {
         return !(*this == rhs);
     }
+    // Swift default argument overspecialization fix
+    VdfPoolChainIndex() {}
+
 
 private:
     friend class VdfPoolChainIndexer;
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/exec/vdf/pullBasedExecutorEngine.h ./pxr/exec/vdf/pullBasedExecutorEngine.h
--- /Users/maddyadams/OpenUSD/pxr/exec/vdf/pullBasedExecutorEngine.h	2025-11-17 14:21:56
+++ ./pxr/exec/vdf/pullBasedExecutorEngine.h	2025-11-17 15:00:15
@@ -1035,9 +1035,9 @@
             // requested because otherwise, it wouldn't be in the schedule,
             // because of VdfScheduler::_RemoveTrivialNodes.)
             TF_WARN(
-                "No value set for output " + output.GetDebugName() +
-                " of type " + output.GetSpec().GetType().GetTypeName() +
-                " named " + output.GetName().GetString());
+                ("No value set for output " + output.GetDebugName() +
+                 " of type " + output.GetSpec().GetType().GetTypeName() +
+                 " named " + output.GetName().GetString()).c_str());
 
             //XXX: This is not 100% right when we use a single data flow
             //     element to hold multiple values (as we do for shaped
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/exec/vdf/sparseInputTraverser.cpp ./pxr/exec/vdf/sparseInputTraverser.cpp
--- /Users/maddyadams/OpenUSD/pxr/exec/vdf/sparseInputTraverser.cpp	2025-08-26 10:20:00
+++ ./pxr/exec/vdf/sparseInputTraverser.cpp	2025-11-17 15:00:20
@@ -28,70 +28,6 @@
 
 ////////////////////////////////////////////////////////////////////////////////
 
-class VdfSparseInputTraverser::_PrioritizedOutput
-{
-public:
-    _PrioritizedOutput(
-        const VdfOutput *output,
-        const VdfMask   &dependencyMask)
-    :   _output(output),
-        _dependencyBits(dependencyMask.GetBits())
-    { }
-
-    _PrioritizedOutput(
-        const VdfOutput *output,
-        const VdfMask   &dependencyMask,
-        const VdfObjectPtrVector &basePath,
-        const VdfConnection *pathElement)
-    :   _output(output),
-        _dependencyBits(dependencyMask.GetBits()),
-        _path(std::make_shared<VdfObjectPtrVector>(basePath))
-    {
-        if (pathElement) {
-            _path->push_back(pathElement);
-        }
-    }
-
-    /// Returns the output.
-    ///
-    const VdfOutput *GetOutput() const {
-        return _output;
-    }
-
-    /// Returns the accumulated dependency bits.
-    ///
-    const VdfMask::Bits &GetDependencyBits() const {
-        return _dependencyBits;
-    }
-
-    /// Extends this prioritized output with \p dependencyMask and
-    /// \p parentCacheIndex.
-    ///
-    void Extend(const VdfMask &dependencyMask) {
-        _dependencyBits |= dependencyMask.GetBits();
-    }
-
-    /// Returns the path, or a reference to NULL if we have no path.
-    const VdfObjectPtrVector &GetPath() const
-    {
-        static VdfObjectPtrVector empty;
-        return _path ? *_path : empty;
-    }
-
-private:
-
-    // The output.
-    const VdfOutput *_output;
-
-    // The (accumulated) dependency mask.
-    VdfMask::Bits _dependencyBits;
-
-    // The first path that leads to this pool output.
-    // The _path is held via shared pointer because we use this call as
-    // value type.
-    std::shared_ptr<VdfObjectPtrVector> _path;
-};
-
 class VdfSparseInputTraverser::_StackFrame
 {
 public:
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/exec/vdf/sparseInputTraverser.h ./pxr/exec/vdf/sparseInputTraverser.h
--- /Users/maddyadams/OpenUSD/pxr/exec/vdf/sparseInputTraverser.h	2025-08-26 10:20:00
+++ ./pxr/exec/vdf/sparseInputTraverser.h	2025-11-17 15:00:22
@@ -169,7 +169,69 @@
 private:
 
     // A type used to represent an input in a priority queue.
-    class _PrioritizedOutput;
+    class _PrioritizedOutput
+    {
+    public:
+        _PrioritizedOutput(
+            const VdfOutput *output,
+            const VdfMask   &dependencyMask)
+        :   _output(output),
+            _dependencyBits(dependencyMask.GetBits())
+        { }
+
+        _PrioritizedOutput(
+            const VdfOutput *output,
+            const VdfMask   &dependencyMask,
+            const VdfObjectPtrVector &basePath,
+            const VdfConnection *pathElement)
+        :   _output(output),
+            _dependencyBits(dependencyMask.GetBits()),
+            _path(std::make_shared<VdfObjectPtrVector>(basePath))
+        {
+            if (pathElement) {
+                _path->push_back(pathElement);
+            }
+        }
+
+        /// Returns the output.
+        ///
+        const VdfOutput *GetOutput() const {
+            return _output;
+        }
+
+        /// Returns the accumulated dependency bits.
+        ///
+        const VdfMask::Bits &GetDependencyBits() const {
+            return _dependencyBits;
+        }
+
+        /// Extends this prioritized output with \p dependencyMask and
+        /// \p parentCacheIndex.
+        ///
+        void Extend(const VdfMask &dependencyMask) {
+            _dependencyBits |= dependencyMask.GetBits();
+        }
+
+        /// Returns the path, or a reference to NULL if we have no path.
+        const VdfObjectPtrVector &GetPath() const
+        {
+            static VdfObjectPtrVector empty;
+            return _path ? *_path : empty;
+        }
+
+    private:
+
+        // The output.
+        const VdfOutput *_output;
+
+        // The (accumulated) dependency mask.
+        VdfMask::Bits _dependencyBits;
+
+        // The first path that leads to this pool output.
+        // The _path is held via shared pointer because we use this call as
+        // value type.
+        std::shared_ptr<VdfObjectPtrVector> _path;
+    };
 
     // A map from pool chain index to prioritized output, used to ensure that we
     // process outputs in their order in the pool chain.
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/imaging/hd/dependencySchema.h ./pxr/imaging/hd/dependencySchema.h
--- /Users/maddyadams/OpenUSD/pxr/imaging/hd/dependencySchema.h	2025-11-17 14:21:56
+++ ./pxr/imaging/hd/dependencySchema.h	2025-11-17 15:00:38
@@ -52,6 +52,9 @@
     HdDependencySchema(HdContainerDataSourceHandle container)
       : HdSchema(container) {}
 
+    // Swift default argument overspecialization fix
+    HdDependencySchema() : HdSchema() {}
+
     /// @}
 
 // --(BEGIN CUSTOM CODE: Schema Methods)--
@@ -124,4 +127,4 @@
 
 PXR_NAMESPACE_CLOSE_SCOPE
 
-#endif
\ No newline at end of file
+#endif
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/imaging/hd/mergingSceneIndex.h ./pxr/imaging/hd/mergingSceneIndex.h
--- /Users/maddyadams/OpenUSD/pxr/imaging/hd/mergingSceneIndex.h	2025-11-17 14:21:56
+++ ./pxr/imaging/hd/mergingSceneIndex.h	2025-11-17 15:00:40
@@ -153,6 +153,9 @@
         , sceneRoot(sceneRoot)
         {
         }
+
+        // Swift default argument overspecialization fix
+        _InputEntry() {}
     };
 
     // We observe that most merging scene indexes have few inputs, such as 2.
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/imaging/hd/schema.h ./pxr/imaging/hd/schema.h
--- /Users/maddyadams/OpenUSD/pxr/imaging/hd/schema.h	2025-11-17 14:21:56
+++ ./pxr/imaging/hd/schema.h	2025-11-17 15:00:42
@@ -28,6 +28,8 @@
     HdSchema(HdContainerDataSourceHandle container)
     : _container(container) {}
 
+    // Swift default argument overspecialization fix
+    HdSchema() {}
 
     /// Returns the container data source that this schema is interpreting.
     HD_API
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/imaging/hdsi/debuggingSceneIndex.cpp ./pxr/imaging/hdsi/debuggingSceneIndex.cpp
--- /Users/maddyadams/OpenUSD/pxr/imaging/hdsi/debuggingSceneIndex.cpp	2025-08-26 10:20:00
+++ ./pxr/imaging/hdsi/debuggingSceneIndex.cpp	2025-11-17 15:00:54
@@ -29,62 +29,6 @@
 // It does produce a non-trivial data source for /foo.
 const bool implicitlyAddedAncestorsHaveEmptyType = true;
 
-// Per prim-info.
-//
-// We always store a prim info for all ancestors as well.
-// In particular, we always store a prim info for the absolute root /.
-//
-struct _PrimInfo
-{
-    // Does a prim exist?
-    //
-    // Note that the HdSceneIndexBase does not specify whether a prim "exists".
-    //
-    // There are two notions of existence:
-    // - The strong form is that GetPrim("/foo") returns a non-empty prim type
-    //   or non-null data source handle.
-    // - The weak form (existence in namespace) is that a prim exists at a path
-    //   if (without a subsequent PrimRemovedEntry):
-    //   * We have received a PrimAddedEntry for the path or a descendant path
-    //   * GetPrim for path or a descendant path returned a non-empty prim type
-    //     or non-null data source
-    //   * GetChildPrimPaths for path or a descendant path was non-empty
-    //   * path is in GetChildPrimPaths(parentPath)
-    //
-    // Here we assume the weaker form.
-    //
-    // If a prim exists (in namespace), there will be a prim-info for all its
-    // ancestors which are also assumed to exist.
-    //
-    // Note that the debugging scene index (lazily) only queries GetPrim or
-    // GetChildPrimPaths itself when the client calls that method.
-    //
-    // If we receive a PrimRemovedEntry, we set _PrimInfo::exists = false for
-    // the corresponding prim info. Such a _PrimInfo has no descendants.
-    //
-    // Note that the implementation could be changed to just use a bool if
-    // we were to use _PrimInfo::insert instead of _PrimInfo[].
-    //
-    std::optional<bool> existsInNamespace;
-
-    // Do we know all children of this prim?
-    //
-    // True if GetChildPrimPaths(path) was called or we received
-    // PrimRemovedEntry(path).
-    //
-    bool allChildrenKnown = false;
-
-    // primType if known.
-    std::optional<TfToken> primType;
-
-    // Does this prim have a non-null ptr data source?
-    //
-    // Future work might store more information about the data source and wrap
-    // it so that we can track which values were returned to a client.
-    //
-    std::optional<bool> hasDataSource;
-};
-
 void _EmitMessage(const std::string &message)
 {
     // Future work might throw an error/show a stack trace/...
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/imaging/hdsi/debuggingSceneIndex.h ./pxr/imaging/hdsi/debuggingSceneIndex.h
--- /Users/maddyadams/OpenUSD/pxr/imaging/hdsi/debuggingSceneIndex.h	2025-08-26 10:20:00
+++ ./pxr/imaging/hdsi/debuggingSceneIndex.h	2025-11-17 15:00:57
@@ -22,7 +22,61 @@
 namespace HdsiDebuggingSceneIndex_Impl
 {
 
-struct _PrimInfo;
+// Per prim-info.
+//
+// We always store a prim info for all ancestors as well.
+// In particular, we always store a prim info for the absolute root /.
+//
+struct _PrimInfo
+{
+    // Does a prim exist?
+    //
+    // Note that the HdSceneIndexBase does not specify whether a prim "exists".
+    //
+    // There are two notions of existence:
+    // - The strong form is that GetPrim("/foo") returns a non-empty prim type
+    //   or non-null data source handle.
+    // - The weak form (existence in namespace) is that a prim exists at a path
+    //   if (without a subsequent PrimRemovedEntry):
+    //   * We have received a PrimAddedEntry for the path or a descendant path
+    //   * GetPrim for path or a descendant path returned a non-empty prim type
+    //     or non-null data source
+    //   * GetChildPrimPaths for path or a descendant path was non-empty
+    //   * path is in GetChildPrimPaths(parentPath)
+    //
+    // Here we assume the weaker form.
+    //
+    // If a prim exists (in namespace), there will be a prim-info for all its
+    // ancestors which are also assumed to exist.
+    //
+    // Note that the debugging scene index (lazily) only queries GetPrim or
+    // GetChildPrimPaths itself when the client calls that method.
+    //
+    // If we receive a PrimRemovedEntry, we set _PrimInfo::exists = false for
+    // the corresponding prim info. Such a _PrimInfo has no descendants.
+    //
+    // Note that the implementation could be changed to just use a bool if
+    // we were to use _PrimInfo::insert instead of _PrimInfo[].
+    //
+    std::optional<bool> existsInNamespace;
+
+    // Do we know all children of this prim?
+    //
+    // True if GetChildPrimPaths(path) was called or we received
+    // PrimRemovedEntry(path).
+    //
+    bool allChildrenKnown = false;
+
+    // primType if known.
+    std::optional<TfToken> primType;
+
+    // Does this prim have a non-null ptr data source?
+    //
+    // Future work might store more information about the data source and wrap
+    // it so that we can track which values were returned to a client.
+    //
+    std::optional<bool> hasDataSource;
+};
 using _PrimInfoSharedPtr = std::shared_ptr<_PrimInfo>;
 using _PrimMap = std::map<SdfPath, _PrimInfo>;
 
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/imaging/hdx/taskControllerSceneIndex.cpp ./pxr/imaging/hdx/taskControllerSceneIndex.cpp
--- /Users/maddyadams/OpenUSD/pxr/imaging/hdx/taskControllerSceneIndex.cpp	2025-11-17 14:21:56
+++ ./pxr/imaging/hdx/taskControllerSceneIndex.cpp	2025-11-17 15:01:09
@@ -1466,7 +1466,7 @@
     if (_aovNames == aovNames) {
         return;
     }
-    _aovNames = _aovNames;
+    _aovNames = aovNames;
 
     _SetRenderOutputs(_ResolvedRenderOutputs(aovNames, _IsForStorm()));
 
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/usd/sdf/predicateProgram.h ./pxr/usd/sdf/predicateProgram.h
--- /Users/maddyadams/OpenUSD/pxr/usd/sdf/predicateProgram.h	2025-08-26 10:20:00
+++ ./pxr/usd/sdf/predicateProgram.h	2025-11-17 15:01:22
@@ -208,7 +208,7 @@
 
     if (!errs.empty()) {
         prog = {};
-        TF_RUNTIME_ERROR(errs);
+        TF_RUNTIME_ERROR(errs.c_str());
     }
     return prog;
 }
diff -Nura --exclude .git --exclude *.orig --exclude .DS_Store --exclude *.pyc /Users/maddyadams/OpenUSD/pxr/usd/usdMtlx/utils.cpp ./pxr/usd/usdMtlx/utils.cpp
--- /Users/maddyadams/OpenUSD/pxr/usd/usdMtlx/utils.cpp	2025-08-26 10:20:01
+++ ./pxr/usd/usdMtlx/utils.cpp	2025-11-17 15:01:32
@@ -16,6 +16,8 @@
 #include "pxr/usd/sdf/types.h"
 #include "pxr/usd/sdr/shaderProperty.h"
 #include "pxr/base/arch/fileSystem.h"
+#include "pxr/base/arch/symbols.h"
+#include "pxr/base/arch/systemInfo.h"
 #include "pxr/base/gf/matrix3d.h"
 #include "pxr/base/gf/matrix4d.h"
 #include "pxr/base/gf/vec2f.h"
@@ -183,6 +185,20 @@
     stdlibSearchPaths =
         _MergeSearchPaths(stdlibSearchPaths, { PXR_MATERIALX_STDLIB_DIR });
 #endif
+    
+    std::string binaryPath;
+    ArchGetAddressInfo(reinterpret_cast<void*>(&_ComputeStdlibSearchPaths), &binaryPath,
+                       nullptr, nullptr, nullptr);
+    if (!binaryPath.empty()) {
+        // binaryPath: .../Usd_UsdMtlx.framework/Versions/A/Usd_UsdMtlx
+        // toAdd: .../Usd_UsdMtlx.framework/Versions/A/Resources/MaterialX_Libraries/libraries
+        // Make toAdd strongest, because app bundles with sandboxing pick up the build directory
+        // if it exists, then fail to load and don't continue to the next path
+        std::string toAdd = TfStringCatPaths(binaryPath, "../Resources/MaterialX_Libraries/libraries");
+        stdlibSearchPaths = _MergeSearchPaths({ toAdd }, stdlibSearchPaths);
+        toAdd = TfStringCatPaths(binaryPath, "../Resources_iOS/MaterialX_Libraries/libraries");
+        stdlibSearchPaths = _MergeSearchPaths({ toAdd }, stdlibSearchPaths);
+    }
 
     // The MaterialX plugin contains the MaterialX standard
     // library under the libraries location in its resource folder
